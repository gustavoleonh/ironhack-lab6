# ironhack-lab6

### Example CICD configuration YML
<br>

``` yml
name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 21
      uses: actions/setup-java@v3
      with:
        java-version: '21'

    - name: Build with Maven
      run: mvn clean install

    - name: Build Docker image
      run: |
        docker build -t ghcr.io/${{ github.repository }}/your-app-name:${{ github.sha }} .

    - name: Login to GitHub Container Registry
      run: |
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    - name: Push Docker image
      run: |
        docker push ghcr.io/${{ github.repository }}/your-app-name:${{ github.sha }}

  test:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 21
      uses: actions/setup-java@v3
      with:
        java-version: '21'

    - name: Run tests
      run: mvn test

  deploy:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up kubectl
      uses: actions/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Set up AWS CLI
      uses: aws-actions/configure-aws-credentials@v3
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name your-cluster-name

    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/your-deployment-name your-container-name=ghcr.io/${{ github.repository }}/your-app-name:${{ github.sha }}
        kubectl rollout status deployment/your-deployment-name
```
<br>

**Explanation:**

<br>

1. **Trigger on push to `main` branch:** The workflow is configured to run when code is pushed to the `main` branch.
2. **Build Job:**
    * **Checkout code:** Uses the `actions/checkout` action to checkout the code from the repository.
    * **Set up JDK 11:** Uses `actions/setup-java` to install JDK 21.
    * **Build with Maven:** Runs Maven to build the application.
    * **Build Docker image:** Builds a Docker image using the Dockerfile in the repository.
    * **Login to GitHub Container Registry:** Logs in to GHCR using the GitHub token.
    * **Push Docker image:** Pushes the built Docker image to GHCR.
3. **Test Job:**
    * This job depends on the `build` job.
    * **Checkout code, set up JDK, and run tests:** Similar steps as the build job to checkout the code, set up JDK, and run tests using Maven.
4. **Deploy Job:**
    * This job depends on the `test` job.
    * **Checkout code and set up kubectl:** Checks out the code and sets up `kubectl` for interacting with the Kubernetes cluster.
    * **Set up AWS CLI:** Configures AWS CLI using the provided AWS credentials from secrets.
    * **Update kubeconfig:** Updates the kubeconfig to access the EKS cluster.
    * **Deploy to Kubernetes:** Updates the image of the Kubernetes deployment and waits for the rollout to complete.

<br>

**Docker File:**

<br>

```
# Use an official OpenJDK runtime as a parent image
FROM eclipse-temurin:21-jre

# Set the working directory in the container
WORKDIR /app

# Copy the packaged jar file into the container
COPY target/your-app-name-0.0.1-SNAPSHOT.jar app.jar

# Expose the port the app runs on
EXPOSE 8080

# Run the jar file
ENTRYPOINT ["java", "-jar", "app.jar"]
```
<br>

**explanation:**

1. **Base Image:**
    * `FROM eclipse-temurin:21-jre`: Uses the official Eclipse Temurin image with Java 21 runtime environment. Eclipse Temurin is the OpenJDK distribution by the Adoptium project.
2. **Working Directory:**
    * `WORKDIR /app`: Sets the working directory inside the container to `/app`.
3. **Copy Jar File:**
    * `COPY target/your-app-name-0.0.1-SNAPSHOT.jar app.jar`: Copies the Spring Boot jar file from your local machine to the container. Adjust the jar file name to match the name generated by your Maven build.
4. **Expose Port:**
    * `EXPOSE 8080`: Exposes port 8080 on the container, which is the default port for Spring Boot applications.
5. **Run the Application:**
    * `ENTRYPOINT ["java", "-jar", "app.jar"]`: Specifies the command to run the jar file when the container starts.

<br>

#### Enhancements & potential issues:

<br>

**Enhancements of Using Docker in CI/CD:**

1. **Consistency:**
    * **Environment Uniformity:** Docker ensures that the application runs in the same environment across all stages (development, testing, and production). This eliminates "works on my machine" issues.
    * **Dependency Management:** All dependencies are encapsulated within the Docker image, reducing dependency conflicts.
2. **Portability:**
    * **Platform Independence:** Docker containers can run on any system that supports Docker, making it easier to move applications between different environments (e.g., from a developer's laptop to a CI server to production).
    * **Simplified Deployment:** Docker images can be easily shared and deployed through container registries, streamlining the deployment process.
3. **Scalability:**
    * **Efficient Resource Utilization:** Docker containers are lightweight and can be spun up quickly, allowing for efficient scaling up and down based on demand.
    * **Microservices Architecture:** Docker naturally supports microservices architectures, where services can be developed, tested, and deployed independently.
4. **Isolation:**
    * **Process Isolation:** Containers provide isolated environments for applications, which enhances security and stability by preventing interference between services.

**Potential Issues with Docker Integration:**

1. **Security Vulnerabilities:**
    * **Image Vulnerabilities:** Base images may contain vulnerabilities that can be exploited if not regularly updated and scanned.
    * **Privileged Containers:** Running containers with excessive privileges can lead to security risks.
2. **Complexity in Managing Large Numbers of Services:**
    * **Orchestration Overhead:** Managing a large number of containers requires orchestration tools like Kubernetes, which add complexity to the system.
    * **Configuration Management:** Maintaining configurations for multiple services across different environments can become cumbersome.
3. **Networking Challenges:**
    * **Network Overhead:** Container networking can introduce overhead and latency, particularly in complex microservices architectures.
    * **Service Discovery:** Properly configuring service discovery and communication between containers can be challenging.
4. **Storage Management:**
    * **Persistent Storage:** Handling persistent storage in a containerized environment requires additional setup and can be complex compared to traditional environments.
5. **Monitoring and Logging:**
    * **Enhanced Monitoring Needs:** Containers are ephemeral, making it necessary to have robust monitoring and logging solutions to track their health and performance.
    * **Log Aggregation:** Aggregating logs from multiple containers requires additional tools and configurations.
6. **Build Time and Resource Utilization:**
    * **Build Time:** Docker builds can be time-consuming, especially if the Dockerfile is not optimized (e.g., using large base images or not caching dependencies effectively).
    * **Resource Consumption:** Running multiple containers simultaneously can strain system resources, particularly on shared CI/CD infrastructure.

<br>

### Mitigation Strategies:

1. **Security Best Practices:**
    * Regularly update base images and use trusted sources.
    * Implement vulnerability scanning tools (e.g., Trivy, Clair, Checkmarks, blackduc, Snyk) in the CI/CD pipeline.
    * Use the principle of least privilege for running containers.
2. **Orchestration and Management:**
    * Use Kubernetes or Docker Swarm for managing container orchestration.
    * Employ configuration management tools like Helm for Kubernetes to manage complex configurations.
3. **Networking and Storage:**
    * Optimize container networking by using efficient network plugins and ensuring proper configuration.
    * Use Kubernetes Persistent Volumes or cloud storage solutions to handle persistent data.
4. **Monitoring and Logging:**
    * Integrate with monitoring tools like Prometheus and Grafana for real-time metrics.
    * Use centralized logging solutions like ELK (Elasticsearch, Logstash, Kibana) stack or Fluentd to aggregate and analyze logs.
5. **Optimizing Builds:**
    * Use multi-stage builds to minimize the size of the final Docker image.
    * Leverage caching mechanisms to speed up build times.
    * Optimize Dockerfile to reduce the number of layers and improve efficiency.
